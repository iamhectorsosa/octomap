{
  "config": {
    "config.go": "package config\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/iamhectorsosa/octomap/internal/entity\"\n)\n\nfunc New(args []string) (*entity.Config, error) {\n\tif len(args) \u003c 2 {\n\t\treturn nil, fmt.Errorf(\"Usage: user/repo [--dir] [--branch] [--include] [--exclude] [--output]\")\n\t}\n\n\trepo := args[1]\n\trepoParts := strings.Split(repo, \"/\")\n\tif len(repoParts) != 2 {\n\t\treturn nil, fmt.Errorf(\"error user/repo format: %s\", repo)\n\t}\n\n\tfs := flag.NewFlagSet(\"flags\", flag.ContinueOnError)\n\tfs.SetOutput(io.Discard)\n\n\tdir := fs.String(\"dir\", \"\", \"Target directory within the repository\")\n\tbranch := fs.String(\"branch\", \"main\", \"Branch to clone (default: main)\")\n\tincludeSuffixes := fs.String(\"include\", \"\", \"Comma-separated list of included file extensions\")\n\texcludeSuffixes := fs.String(\"exclude\", \"\", \"Comma-separated list of excluded file extensions\")\n\toutput := fs.String(\"output\", \"\", \"Output directory\")\n\n\terr := fs.Parse(args[2:])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error parsing flags: %v\", err)\n\t}\n\n\tinclude := strings.Split(*includeSuffixes, \",\")\n\texclude := strings.Split(*excludeSuffixes, \",\")\n\n\tif len(include) == 1 \u0026\u0026 include[0] == \"\" {\n\t\tinclude = nil\n\t}\n\tif len(exclude) == 1 \u0026\u0026 exclude[0] == \"\" {\n\t\texclude = nil\n\t}\n\n\trepoName := repoParts[1]\n\turl := fmt.Sprintf(\"https://github.com/%s/archive/refs/heads/%s.tar.gz\", repo, *branch)\n\tresolvedDir := fmt.Sprintf(\"%s-%s\", repoName, *branch)\n\n\tif *dir != \"\" {\n\t\tresolvedDir += \"/\" + *dir\n\t}\n\n\tresolvedPath, err := resolvePath(*output)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot resolve path: %v\", err)\n\t}\n\n\tif resolvedPath != \"\" {\n\t\text := filepath.Ext(resolvedPath)\n\t\tif ext != \"\" {\n\t\t\treturn nil, fmt.Errorf(\"invalid directory format: %s\", *output)\n\t\t}\n\n\t\t_, err = os.Stat(resolvedPath)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\treturn nil, fmt.Errorf(\"directory doesn't exist: %v\", err)\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"error checking directory: %v\", err)\n\t\t}\n\t}\n\n\treturn \u0026entity.Config{\n\t\tRepo:    repoName,\n\t\tDir:     resolvedDir,\n\t\tUrl:     url,\n\t\tInclude: include,\n\t\tExclude: exclude,\n\t\tOutput:  resolvedPath,\n\t}, nil\n}\n\nfunc resolvePath(path string) (string, error) {\n\tpath = os.ExpandEnv(path)\n\n\tif len(path) \u003e 2 \u0026\u0026 path[:2] == \"~/\" {\n\t\thome, err := os.UserHomeDir()\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"reading home dir: %v\", err)\n\t\t}\n\t\treturn filepath.Join(home, path[2:]), nil\n\t}\n\n\treturn path, nil\n}\n"
  },
  "entity": {
    "entity.go": "package entity\n\ntype Config struct {\n\tRepo    string\n\tDir     string\n\tUrl     string\n\tOutput  string\n\tInclude []string\n\tExclude []string\n}\n\ntype Update struct {\n\tErr         error\n\tDescription string\n}\n"
  },
  "model": {
    "model.go": "package model\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/bubbles/spinner\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/iamhectorsosa/octomap/internal/entity\"\n\t\"github.com/iamhectorsosa/octomap/internal/repository\"\n)\n\nvar (\n\thelpStyle = lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\")).Render\n\tmainStyle = lipgloss.NewStyle().MarginLeft(1)\n\tcheckMark = lipgloss.NewStyle().Foreground(lipgloss.Color(\"42\")).SetString(\"‚úì\")\n\terrorMark = lipgloss.NewStyle().Foreground(lipgloss.Color(\"160\")).SetString(\"x\")\n)\n\ntype model struct {\n\tconfig   *entity.Config\n\tch       chan entity.Update\n\tupdates  []entity.Update\n\tspinner  spinner.Model\n\tcomplete bool\n\tquitting bool\n}\n\nfunc New(cfg *entity.Config) model {\n\tsp := spinner.New()\n\tsp.Spinner = spinner.Dot\n\tsp.Style = lipgloss.NewStyle().Foreground(lipgloss.Color(\"205\"))\n\n\treturn model{\n\t\tconfig:  cfg,\n\t\tspinner: sp,\n\t\tupdates: []entity.Update{},\n\t\tch:      make(chan entity.Update),\n\t}\n}\n\nfunc (m model) Init() tea.Cmd {\n\treturn tea.Batch(\n\t\tm.spinner.Tick,\n\t\tm.runPretendProcess(),\n\t)\n}\n\nfunc (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.KeyMsg:\n\t\tm.quitting = true\n\t\treturn m, tea.Quit\n\tcase spinner.TickMsg:\n\t\tvar cmd tea.Cmd\n\t\tm.spinner, cmd = m.spinner.Update(msg)\n\t\treturn m, cmd\n\tcase processFinishedMsg:\n\t\tup := entity.Update{\n\t\t\tDescription: msg.Description,\n\t\t\tErr:         msg.Err,\n\t\t}\n\n\t\tm.updates = append(m.updates, up)\n\t\tif len(m.updates) \u003e 6 {\n\t\t\tm.updates = m.updates[1:]\n\t\t}\n\t\treturn m, m.runPretendProcess()\n\tcase processEndMsg:\n\t\tm.complete = true\n\t\treturn m, tea.Quit\n\t}\n\n\treturn m, nil\n}\n\nfunc (m model) View() string {\n\ts := \"\\n\"\n\tif !m.complete {\n\t\ts += m.spinner.View()\n\t} else {\n\t\ts += \"  \"\n\t}\n\ts += \"üêô Mapping repository...\\n\\n\"\n\n\tfor _, res := range m.updates {\n\t\tmark := checkMark\n\t\tif res.Err != nil {\n\t\t\tmark = errorMark\n\t\t}\n\t\ts += fmt.Sprintf(\"%s %s\\n\", mark, res.Description)\n\t}\n\n\tif !m.complete {\n\t\ts += helpStyle(\"\\nPress any key to exit\")\n\t} else {\n\t\ts += \"\\nProcess finished!\\n\\n\"\n\t}\n\n\treturn mainStyle.Render(s)\n}\n\ntype (\n\tprocessEndMsg      struct{}\n\tprocessFinishedMsg entity.Update\n)\n\nfunc (m model) runPretendProcess() tea.Cmd {\n\treturn func() tea.Msg {\n\t\tif len(m.updates) == 0 {\n\t\t\tgo repository.ProcessRepo(\n\t\t\t\tm.config.Repo,\n\t\t\t\tm.config.Url,\n\t\t\t\tm.config.Dir,\n\t\t\t\tm.config.Output,\n\t\t\t\tm.config.Include,\n\t\t\t\tm.config.Exclude,\n\t\t\t\tm.ch,\n\t\t\t\t25*time.Millisecond,\n\t\t\t)\n\t\t}\n\n\t\tmsg, ok := \u003c-m.ch\n\t\tif !ok {\n\t\t\treturn processEndMsg{}\n\t\t}\n\n\t\treturn processFinishedMsg{\n\t\t\tDescription: msg.Description,\n\t\t\tErr:         msg.Err,\n\t\t}\n\t}\n}\n"
  },
  "repository": {
    "repository.go": "package repository\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/iamhectorsosa/octomap/internal/entity\"\n)\n\nfunc ProcessRepo(repo, url, dir, output string, include, exclude []string, ch chan\u003c- entity.Update, delay time.Duration) {\n\tdefer close(ch)\n\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tch \u003c- entity.Update{\n\t\t\tDescription: \"Request error getting tarball\",\n\t\t\tErr:         err,\n\t\t}\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tch \u003c- entity.Update{\n\t\t\tDescription: fmt.Sprintf(\"Request error getting tarbal with status code: %d\", resp.StatusCode),\n\t\t\tErr:         fmt.Errorf(\"status code: %d\", resp.StatusCode),\n\t\t}\n\t\treturn\n\t}\n\n\tdata, err := TarballReader(dir, include, exclude, resp.Body, ch, delay)\n\tif err != nil {\n\t\tch \u003c- entity.Update{\n\t\t\tDescription: fmt.Sprintf(\"Tarball error: %v\", err),\n\t\t\tErr:         err,\n\t\t}\n\t\treturn\n\t}\n\n\tf, err := os.Create(fmt.Sprintf(\"%s%s%s.json\", output, repo, time.Now().Format(\"20060102_150405\")))\n\tif err != nil {\n\t\tch \u003c- entity.Update{\n\t\t\tDescription: fmt.Sprintf(\"Output file error: %v\", err),\n\t\t\tErr:         err,\n\t\t}\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tencoder := json.NewEncoder(f)\n\tencoder.SetIndent(\"\", \"  \")\n\tif err := encoder.Encode(data); err != nil {\n\t\tch \u003c- entity.Update{\n\t\t\tDescription: fmt.Sprintf(\"Output encoding error: %v\", err),\n\t\t\tErr:         err,\n\t\t}\n\t\treturn\n\t}\n}\n\nfunc TarballReader(\n\tdir string,\n\tinclude,\n\texclude []string,\n\tr io.Reader,\n\tch chan\u003c- entity.Update,\n\tdelay time.Duration,\n) (map[string]interface{}, error) {\n\tgzipReader, err := gzip.NewReader(r)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error decompressing tarbal: %v\", err)\n\t}\n\tdefer gzipReader.Close()\n\n\tdata := make(map[string]interface{})\n\n\ttarReader := tar.NewReader(gzipReader)\n\tfor {\n\t\thdr, err := tarReader.Next()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error reading tarball: %v\", err)\n\t\t}\n\n\t\tif hdr.Typeflag == tar.TypeDir || !strings.HasPrefix(hdr.Name, dir) {\n\t\t\tcontinue\n\t\t}\n\n\t\trelativePath := strings.TrimPrefix(hdr.Name, dir+\"/\")\n\n\t\tshouldProcess := true\n\t\tif len(include) \u003e 0 {\n\t\t\tshouldProcess = false\n\t\t\tfor _, suffix := range include {\n\t\t\t\tif strings.HasSuffix(relativePath, suffix) {\n\t\t\t\t\tshouldProcess = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif shouldProcess \u0026\u0026 len(exclude) \u003e 0 {\n\t\t\tfor _, suffix := range exclude {\n\t\t\t\tif strings.HasSuffix(relativePath, suffix) {\n\t\t\t\t\tshouldProcess = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif shouldProcess {\n\t\t\tvar buf bytes.Buffer\n\t\t\tif _, err := io.Copy(\u0026buf, tarReader); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error reading file: %s - %v\", hdr.Name, err)\n\t\t\t}\n\n\t\t\tpathParts := strings.Split(relativePath, \"/\")\n\n\t\t\tcurrent := data\n\t\t\tfor i, part := range pathParts {\n\t\t\t\tif i == len(pathParts)-1 {\n\t\t\t\t\tcurrent[part] = buf.String()\n\t\t\t\t\ttime.Sleep(delay)\n\t\t\t\t\tch \u003c- entity.Update{\n\t\t\t\t\t\tDescription: relativePath,\n\t\t\t\t\t\tErr:         nil,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif _, exists := current[part]; !exists {\n\t\t\t\t\t\tcurrent[part] = make(map[string]interface{})\n\t\t\t\t\t}\n\n\t\t\t\t\tvar ok bool\n\t\t\t\t\tcurrent, ok = current[part].(map[string]interface{})\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"unexpected structure found on: %s\", hdr.Name)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn data, nil\n}\n"
  }
}
